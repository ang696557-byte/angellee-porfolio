<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIND & VOID | ROOTED / LEVITATING</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Syncopate:wght@400;700&family=Noto+Sans:wght@100;300;400&family=Orbitron:wght@700;900&family=Share+Tech+Mono&family=Noto+Serif:wght@700&display=swap');

        /* --- 0. Global Settings --- */
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background-color: #020202; font-family: 'Noto Sans', sans-serif; color: #fff; overflow-x: hidden; cursor: none; /* Hide default cursor for immersion */ }
        ::-webkit-scrollbar { width: 0; }

        /* --- 1. Film Grain Overlay (Texture Layer) --- */
        .film-grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9998; /* Top layer, below flash */
            opacity: 0.08; /* Subtle noise */
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='1'/%3E%3C/svg%3E");
            animation: grain-move 8s steps(10) infinite;
        }
        @keyframes grain-move {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5%, -5%); }
            20% { transform: translate(-10%, 5%); }
            30% { transform: translate(5%, -10%); }
            40% { transform: translate(-5%, 15%); }
            50% { transform: translate(-10%, 5%); }
            60% { transform: translate(15%, 0); }
            70% { transform: translate(0, 10%); }
            80% { transform: translate(-15%, 0); }
            90% { transform: translate(10%, 5%); }
        }

        /* --- 2. Digital Wisp (Mouse Follower Canvas) --- */
        #wisp-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9990; /* High z-index */
            mix-blend-mode: screen; /* Glowing effect */
        }

        /* --- 3. Audio Toggle UI --- */
        #audio-toggle {
            position: fixed;
            bottom: 30px;
            left: 40px;
            z-index: 100;
            font-family: 'Syncopate';
            font-size: 10px;
            color: rgba(255,255,255,0.5);
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 12px;
            transition: 0.3s;
            mix-blend-mode: difference;
        }
        #audio-toggle:hover { color: #ffae00; border-color: #ffae00; }
        .eq-bar { display: inline-block; width: 2px; height: 8px; background: currentColor; margin-right: 2px; animation: eq-bounce 0.5s infinite ease-in-out alternate; }
        .eq-bar:nth-child(2) { animation-delay: 0.1s; height: 12px; }
        .eq-bar:nth-child(3) { animation-delay: 0.2s; height: 6px; }
        #audio-toggle.muted .eq-bar { animation: none; height: 2px; }
        @keyframes eq-bounce { 0% { transform: scaleY(0.5); } 100% { transform: scaleY(1.5); } }

        /* --- 4. CREDITS FOOTER (ENGLISH) --- */
        .credits-fixed {
            position: fixed;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-family: 'Noto Sans', sans-serif;
            font-size: 10px;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.6);
            z-index: 200;
            pointer-events: none;
            mix-blend-mode: difference; /* Visible on white and black */
            text-transform: uppercase;
        }

        /* --- Existing Styles --- */
        #soul-tree-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; mix-blend-mode: screen; opacity: 0; transition: opacity 0.5s; }
        body.active #soul-tree-canvas { opacity: 0.6; }
        .ambient-glow { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at 50% 100%, #2a1500 0%, #000 75%); z-index: -1; }
        #flash-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 9999; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        body.flashing #flash-overlay { opacity: 1; transition: none; }

        #start-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #020202; z-index: 5000; display: flex; justify-content: center; align-items: center; transition: opacity 0.5s; }
        #start-screen.hidden { display: none; }
        #box-container { position: relative; width: 260px; height: 180px; background: linear-gradient(135deg, #1a0d00, #000); border: 1px solid rgba(255, 174, 0, 0.3); box-shadow: 0 0 30px rgba(255, 69, 0, 0.15); display: flex; justify-content: center; align-items: center; color: rgba(255,255,255,0.9); font-size: 16px; letter-spacing: 4px; font-family: 'Syncopate'; cursor: pointer; transition: all 0.5s; z-index: 5001; }
        #box-container:hover { border-color: #ffae00; box-shadow: 0 0 60px rgba(255, 174, 0, 0.4); transform: scale(1.02); }

        #main-interface { position: fixed; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; pointer-events: none; transition: opacity 1s ease; overflow-y: auto; overflow-x: hidden; scroll-behavior: smooth; z-index: 10; }
        body.active #main-interface { opacity: 1; pointer-events: auto; }
        
        .tree-header { height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; z-index: 10; padding: 0 20px; }
        .neon-title { font-family: 'Orbitron'; font-weight: 900; font-size: 8vw; line-height: 1.1; color: transparent; -webkit-text-stroke: 2px #ffae00; text-align: center; margin-bottom: 50px; text-shadow: 0 0 20px #ffae00; animation: jellyfish 6s ease-in-out infinite; }
        @keyframes jellyfish { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }
        .header-monologue { font-family: 'Share Tech Mono', monospace; font-size: 14px; line-height: 2; color: rgba(255, 255, 255, 0.8); text-align: left; max-width: 600px; margin: 0 auto; border-left: 2px solid #ff4500; padding-left: 20px; text-transform: uppercase; letter-spacing: 1px; background: linear-gradient(90deg, rgba(255,69,0,0.1) 0%, transparent 100%); }

        .content-stream { position: relative; max-width: 1000px; margin: 0 auto; padding-bottom: 100px; }
        .vine-section { position: relative; padding-top: 20vh; padding-bottom: 15vh; max-width: 1600px; margin: 0 auto; z-index: 1; }
        #global-vine-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; overflow: visible; }
        .vine-path-bg { fill: none; stroke: rgba(255,255,255,0.1); stroke-width: 12px; stroke-linecap: round; }
        .vine-path-main { fill: none; stroke: url(#vineGradient); stroke-width: 8px; stroke-linecap: round; filter: drop-shadow(0 0 10px #ff4500); stroke-dasharray: 3000; stroke-dashoffset: 3000; transition: stroke-dashoffset 0.1s linear; }

        .intro-wide-block { width: 90%; max-width: 1200px; height: 350px; margin: 0 auto 80px auto; position: relative; z-index: 5; }
        .intro-img-box { width: 100%; height: 100%; overflow: hidden; border: 1px solid rgba(255, 174, 0, 0.5); border-radius: 4px; background: #000; }
        .intro-img-box img { width: 100%; height: 100%; object-fit: cover; }

        .node-block { display: flex; justify-content: center; align-items: center; margin-bottom: 60px; position: relative; z-index: 2; gap: 80px; opacity: 0; transform: translateY(50px); transition: all 1s; }
        .node-block.is-visible { opacity: 1; transform: translateY(0); }
        .node-block:nth-child(odd) { flex-direction: row; } .node-block:nth-child(even) { flex-direction: row-reverse; }
        .node-meta { width: 30%; min-width: 250px; }
        .meta-id { font-family: 'Cinzel'; font-size: 60px; color: #ffae00; display: block; margin-bottom: 10px; }
        .meta-title { font-family: 'Noto Sans'; font-size: 20px; font-weight: 300; letter-spacing: 5px; color: #fff; margin: 0 0 5px 0; text-transform: uppercase; }
        .meta-sub { font-family: 'Syncopate'; font-size: 10px; color: #ff4500; letter-spacing: 2px; display: block; margin-bottom: 10px; }
        .meta-desc { color: #aaa; font-size: 12px; line-height: 1.6; font-weight: 300; }
        .node-visual { width: 350px; perspective: 800px; }

        .cyber-screen { width: 100%; aspect-ratio: 4/3; position: relative; overflow: hidden; background: #000; transition: box-shadow 0.3s; }
        #node-1 .cyber-screen { box-shadow: 0 0 25px rgba(255, 174, 0, 0.3); border: 1px solid rgba(255, 174, 0, 0.2); }
        #node-2 .cyber-screen { box-shadow: 0 0 25px rgba(255, 69, 0, 0.3); border: 1px solid rgba(255, 69, 0, 0.2); }
        #node-3 .cyber-screen { box-shadow: 0 0 25px rgba(0, 150, 255, 0.4); border: 1px solid rgba(0, 150, 255, 0.3); }
        .cyber-screen .slide { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center top; opacity: 0; transition: opacity 1.5s ease-in-out; filter: brightness(0.8) contrast(1.1); z-index: 1; }
        .cyber-screen .slide.active { opacity: 1; transform: scale(1.05); transition: opacity 1.5s ease-in-out, transform 6s linear; }
        .screen-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 4px, 6px 100%; box-shadow: inset 0 0 40px rgba(0,0,0,0.8); }
        .node-visual:hover .slide { filter: brightness(1.1) contrast(1.1); }
        .node-visual:hover .screen-overlay { opacity: 0.3; }

        .transition-title-block { text-align: center; margin: 150px 0 50px 0; opacity: 0; transform: translateY(30px); transition: 1s; }
        .transition-title-block.is-visible { opacity: 1; transform: translateY(0); }
        .trans-title { font-family: 'Orbitron'; font-size: 60px; color: #fff; letter-spacing: 10px; text-shadow: 0 0 30px rgba(255, 174, 0, 0.6); }

        #hologram-stage { position: relative; width: 100vw; height: 100vh; margin: 80px 0; background: radial-gradient(circle at center, rgba(255, 69, 0, 0.05) 0%, transparent 60%); overflow: hidden; border-top: 1px solid rgba(255, 69, 0, 0.4); border-bottom: 1px solid rgba(255, 69, 0, 0.4); }
        #three-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        .holo-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        .scan-line { position: absolute; top: 0; left: 0; width: 100%; height: 2px; background: #ffae00; box-shadow: 0 0 10px #ffae00; animation: scan-move 4s linear infinite; opacity: 0.5; }
        @keyframes scan-move { 0% { top: 0%; opacity: 0; } 100% { top: 100%; opacity: 0; } }

        #synthesis-lab { position: relative; width: 100%; padding: 120px 0; background: #050505; border-top: 1px solid #222; border-bottom: 1px solid #222; z-index: 15; display: flex; flex-direction: column; align-items: center; }
        .lab-connector { position: absolute; top: -50px; left: 50%; width: 2px; height: 100px; background: linear-gradient(to bottom, #ff4500, #ffae00); box-shadow: 0 0 10px #ffae00; z-index: 5; }
        .lab-title-box { text-align: center; margin-bottom: 60px; position: relative; z-index: 2; }
        .lab-sub { font-family: 'Share Tech Mono'; color: #ff4500; letter-spacing: 3px; font-size: 12px; }
        .lab-main-title { font-family: 'Orbitron'; color: #fff; font-size: 32px; letter-spacing: 6px; margin: 10px 0; text-shadow: 0 0 15px rgba(255, 174, 0, 0.3); }
        .lab-grid { display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; width: 95%; max-width: 1400px; }
        .lab-card { width: 350px; height: 500px; border: 1px solid #333; background: #0a0a0a; position: relative; overflow: hidden; transition: 0.3s; }
        .lab-card:hover { border-color: #ffae00; box-shadow: 0 0 40px rgba(255, 69, 0, 0.2); }
        .card-content { position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 30px; box-sizing: border-box; display: flex; flex-direction: column; z-index: 10; pointer-events: none; }
        .card-head { font-family: 'Syncopate'; font-weight: 700; color: #888; border-bottom: 1px solid #333; padding-bottom: 15px; display: flex; justify-content: space-between; margin-bottom: 20px; }
        .card-icon { color: #ff4500; }
        .card-options { pointer-events: auto; display: flex; flex-direction: column; gap: 15px; margin-top: auto; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 4px; border: 1px solid #333; transform: translateY(0); transition: 0.3s; }
        .lab-card:hover .card-options { border-color: #555; }
        .opt-item { font-family: 'Orbitron'; font-size: 14px; color: #888; letter-spacing: 2px; cursor: pointer; padding: 10px; border-left: 2px solid transparent; transition: 0.2s; background: rgba(255,255,255,0.02); }
        .opt-item:hover, .opt-item.active { color: #ffae00; border-left: 2px solid #ffae00; background: rgba(255, 174, 0, 0.1); padding-left: 15px; }
        .opt-item span { display: block; font-family: 'Noto Sans'; font-size: 10px; color: #555; letter-spacing: 0; margin-top: 2px; }
        .visual-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0.4; transition: opacity 0.3s; }
        .lab-card:hover .visual-layer { opacity: 1; }
        .viz-canvas { width: 100%; height: 100%; display: block; }
        #avatar-3d-container { width: 100%; height: 100%; }

        .chronos-section { position: relative; width: 100%; height: 100vh; background: #000; border-top: 1px solid #333; z-index: 20; display: flex; flex-direction: column; transition: background-color 1s ease; overflow: visible !important; }
        .chronos-connector { position: absolute; top: 0; left: 50%; width: 2px; height: 50px; background: linear-gradient(to bottom, #ffae00, transparent); z-index: 25; }
        #chronos-container { width: 100%; flex-grow: 1; position: relative; }
        .gate-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 30px; box-sizing: border-box; }
        .gate-header { text-align: center; margin-top: 20px; }
        .gate-title { font-family: 'Orbitron'; font-size: 30px; letter-spacing: 8px; color: #fff; text-shadow: 0 0 20px rgba(255,255,255,0.5); }
        .gate-sub { font-family: 'Noto Serif'; font-size: 14px; color: #aaa; margin-top: 5px; letter-spacing: 2px; text-transform: uppercase; }
        .gate-hud { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 200px; border: 1px dashed rgba(255,255,255,0.3); border-radius: 50%; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: all 0.5s; opacity: 0; z-index: 30; }
        .gate-hud.active { opacity: 1; border: 4px solid #fff; width: 280px; height: 280px; background: rgba(255,255,255,0.05); box-shadow: 0 0 50px rgba(255,255,255,0.1); }
        .gate-icon { font-size: 40px; margin-bottom: 10px; }
        .gate-status { font-family: 'Syncopate'; font-size: 10px; letter-spacing: 2px; color: #fff; }
        .gate-controls { display: flex; justify-content: space-between; align-items: flex-end; opacity: 0; transition: 1s; }
        .gate-controls.visible { opacity: 1; }
        .gate-guide { font-family: 'Syncopate'; font-size: 10px; color: #888; line-height: 1.6; text-align: left; }
        .gate-monitor { display: flex; gap: 10px; pointer-events: auto; background: rgba(0,0,0,0.5); padding: 5px; border: 1px solid #333; }
        .monitor-screen { width: 80px; height: 60px; background: #111; border: 1px solid #555; transform: scaleX(-1); }
        .monitor-screen video, .monitor-screen canvas { width: 100%; height: 100%; object-fit: cover; }
        .gate-start-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background: rgba(0,0,0,0.8); z-index: 50; transition: opacity 0.5s; }
        .gate-start-layer.hidden { opacity: 0; pointer-events: none; }
        .btn-activate { padding: 20px 50px; border: 2px solid #ffae00; color: #fff; font-family: 'Orbitron'; font-size: 18px; letter-spacing: 4px; background: rgba(0,0,0,0.6); cursor: pointer; transition: 0.3s; box-shadow: 0 0 30px rgba(255, 174, 0, 0.2); pointer-events: auto; }
        .btn-activate:hover { background: #ffae00; color: #000; box-shadow: 0 0 60px #ffae00; }

        #outro-summary { position: relative; width: 100%; height: 100vh; background-color: #000000; display: flex; justify-content: center; align-items: center; z-index: 20; overflow: hidden; }
        #outro-canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: auto; }
        
        #outro-text {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 900px;
            text-align: center;
            font-family: 'Share Tech Mono', monospace; 
            font-size: 1.1rem;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9); /* White text for dark background */
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            z-index: 100;
            pointer-events: none; 
            opacity: 0;
            transition: opacity 1s;
        }
        #outro-text.visible { opacity: 1; }

        .nav-fixed { position: fixed; bottom: 30px; right: 40px; z-index: 100; mix-blend-mode: difference; }
        .nav-link { font-family: 'Syncopate'; font-size: 10px; color: #fff; cursor: pointer; }
        #process-canvas { display: none; }
    </style>
</head>
<body>
    <div class="film-grain"></div>
    
    <canvas id="wisp-canvas"></canvas>

    <div id="flash-overlay"></div>
    <div class="ambient-glow"></div>
    <canvas id="soul-tree-canvas"></canvas>

    <audio id="bgm" loop>
        <source src="audio/audiobgm.mp3" type="audio/mpeg">
    </audio>

    <div id="audio-toggle" onclick="toggleAudio()">
        <span class="eq-bar"></span><span class="eq-bar"></span><span class="eq-bar"></span>
        <span style="margin-left:5px">AUDIO</span>
    </div>

    <div id="start-screen">
        <div id="box-container" onclick="initializeSystem()"><span>INITIALIZE</span></div>
    </div>

    <div id="main-interface">
        <div class="tree-header">
            <h1 class="neon-title">ROOTED<br><span style="font-size:0.5em; color:#fff; -webkit-text-stroke:0;">/</span><br>LEVITATING</h1>
            <div class="header-monologue">
                Departing from the roots of Wing Chun,<br>
                pulsing with the rhythms of Hip-Hop,<br>
                merging into the Pisces reverie.<br><br>
                I once peered at the stage through a screen;<br>
                now stepping out of physical confines,<br>
                I explore the forms of unbound dance.
            </div>
        </div>

        <div class="content-stream">
            <div class="intro-wide-block" id="intro-anchor">
                <div class="intro-img-box"><img src="images/image_e25b31.jpg" alt="Intro"></div>
            </div>

            <section class="vine-section">
                <svg id="global-vine-svg">
                    <defs><linearGradient id="vineGradient" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#ffae00" /><stop offset="100%" stop-color="#ff4500" /></linearGradient></defs>
                    <path id="vine-bg" class="vine-path-bg" /><path id="vine-main" class="vine-path-main" />
                </svg>
                
                <div class="node-block" id="node-1">
                    <div class="node-meta"><span class="meta-id">01</span><span class="meta-sub">Wing Chun</span><h2 class="meta-title">The Square Inch</h2><div class="meta-desc"><p>The body is the first vessel. Amidst the percussion of the wooden dummy and the shadows of old blocks, I established my own coordinate system.</p></div></div>
                    <div class="node-visual">
                        <div class="cyber-screen" data-screen="1">
                            <div class="screen-overlay"></div>
                            <div class="slide active" style="background-image: url('images/poster_wc_1.jpg')"></div>
                            <div class="slide" style="background-image: url('images/poster_wc_2.jpg')"></div>
                            <div class="slide" style="background-image: url('images/poster_wc_3.jpg')"></div>
                            <div class="slide" style="background-image: url('images/poster_wc_4.jpg')"></div>
                        </div>
                    </div>
                </div>

                <div class="node-block" id="node-2">
                    <div class="node-visual">
                        <div class="cyber-screen" data-screen="2">
                            <div class="screen-overlay"></div>
                            <div class="slide active" style="background-image: url('images/poster_hh_1.jpg')"></div>
                            <div class="slide" style="background-image: url('images/poster_hh_2.jpg')"></div>
                            <div class="slide" style="background-image: url('images/poster_hh_3.jpg')"></div>
                        </div>
                    </div>
                    <div class="node-meta"><span class="meta-id">02</span><span class="meta-sub">Flow</span><h2 class="meta-title">West Coast Rhythm</h2><div class="meta-desc"><p>The moment rules were broken. California sunshine pierced through the static of black and white TV, rhythm becoming a new language.</p></div></div>
                </div>

                <div class="node-block" id="node-3">
                    <div class="node-meta"><span class="meta-id">03</span><span class="meta-sub">Void</span><h2 class="meta-title">Wandering the Void</h2><div class="meta-desc"><p>The dissolution of gravity. In the low frequencies of Trip-hop and psychedelic neon, I built a levitating inner stage.</p></div></div>
                    <div class="node-visual">
                        <div class="cyber-screen" data-screen="3">
                            <div class="screen-overlay"></div>
                            <div class="slide active" style="background-image: url('images/poster_void_1.jpg')"></div>
                            <div class="slide" style="background-image: url('images/poster_void_2.jpg')"></div>
                            <div class="slide" style="background-image: url('images/poster_void_3.jpg')"></div>
                        </div>
                    </div>
                </div>
            </section>

            <div class="transition-title-block">
                <div style="width:2px; height:100px; background:#ffae00; margin:0 auto 20px auto;"></div>
                <h2 class="trans-title">INFINITE STAGE</h2>
            </div>
        </div>

        <section id="hologram-stage">
            <div class="scan-line"></div>
            <div id="three-container"></div>
            <div class="holo-ui">
                <div style="position:absolute; top:40px; left:50%; transform:translateX(-50%); text-align:center; color:#fff;">
                    <h3 style="font-family:'Orbitron'; letter-spacing:5px; margin:0;">WING CHUN DATA</h3>
                    <span style="font-family:'Syncopate'; font-size:10px; color:#ff4500;">MOTION CAPTURE</span>
                </div>
            </div>
        </section>

        <section id="synthesis-lab">
            <div class="lab-connector"></div>
            <div class="lab-title-box">
                <span class="lab-sub">DECONSTRUCTING MOVEMENT</span>
                <h2 class="lab-main-title">ELEMENT SYNTHESIS</h2>
                <span class="lab-sub">SELECT PARAMETERS TO RECONSTRUCT</span>
            </div>

            <div class="lab-grid">
                <div class="lab-card" onmouseenter="startAudioPreview()" onmouseleave="stopAudioPreview()">
                    <div class="visual-layer"><canvas id="viz-audio" class="viz-canvas"></canvas></div>
                    <div class="card-content">
                        <div class="card-head"><span>SEQUENCER</span><span class="card-icon">üîä</span></div>
                        <div class="card-options">
                            <div class="opt-item" onmouseover="setAudioMode('zen')">ZEN MODE<span>BINAURAL BEATS</span></div>
                            <div class="opt-item" onmouseover="setAudioMode('hiphop')">BOOM BAP<span>KICK SNARE HAT</span></div>
                            <div class="opt-item" onmouseover="setAudioMode('triphop')">AMBIENT<span>DETUNED SAW</span></div>
                        </div>
                    </div>
                </div>

                <div class="lab-card" onmouseenter="startSceneViz()" onmouseleave="stopSceneViz()">
                    <div class="visual-layer"><canvas id="viz-scene" class="viz-canvas"></canvas></div>
                    <div class="card-content">
                        <div class="card-head"><span>ATMOSPHERE</span><span class="card-icon">üëÅÔ∏è</span></div>
                        <div class="card-options">
                            <div class="opt-item" onmouseover="setSceneMode('void')">VOID<span>MINIMALIST</span></div>
                            <div class="opt-item" onmouseover="setSceneMode('concrete')">CONCRETE<span>URBAN GRID</span></div>
                            <div class="opt-item" onmouseover="setSceneMode('fluid')">FLUID<span>CYBERNETIC</span></div>
                        </div>
                    </div>
                </div>

                <div class="lab-card" onmouseenter="startAvatar()" onmouseleave="stopAvatar()">
                    <div class="visual-layer"><div id="avatar-3d-container"></div></div>
                    <div class="card-content">
                        <div class="card-head"><span>MOTION DATA</span><span class="card-icon">üë§</span></div>
                        <div class="card-options">
                            <div class="opt-item" onmouseover="setAvatarMode('wingchun')">THE MONK<span>TAN SAO / FOOK SAO</span></div>
                            <div class="opt-item" onmouseover="setAvatarMode('hiphop')">THE BREAKER<span>BOUNCE / GROOVE</span></div>
                            <div class="opt-item" onmouseover="setAvatarMode('triphop')">THE GHOST<span>FLOAT / TWIST</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="chronos-section">
            <div class="chronos-connector"></div>
            <div class="gate-start-layer">
                <button class="btn-activate" onclick="initChronosGate()">ACTIVATE CHRONOS GATE</button>
            </div>
            
            <div class="gate-overlay">
                <div class="gate-header">
                    <div class="gate-title" id="gate-ui-title">CHRONOS HUB</div>
                    <div class="gate-sub" id="gate-ui-sub">Connection ¬∑ Past & Future</div>
                </div>
                
                <div class="gate-hud" id="gate-hud">
                    <div class="gate-icon" id="gate-ui-icon">‚õ©Ô∏è</div>
                    <div class="gate-status" id="gate-ui-status">STANDBY</div>
                </div>
                <div class="gate-controls">
                    <div class="gate-guide">
                        üëä <b>CENTER:</b> HIP-HOP (BURST)<br>
                        üåä <b>SIDES:</b> TRIP-HOP (FLOW)<br>
                        üßò <b>STILL:</b> ZEN (RESET)
                    </div>
                    <div class="gate-monitor">
                        <div class="monitor-screen"><video id="webcam-preview" autoplay muted playsinline></video></div>
                        <div class="monitor-screen"><canvas id="motion-debug"></canvas></div>
                    </div>
                </div>
            </div>
            <div id="chronos-container"></div>
        </section>

        <section id="outro-summary">
            <div id="outro-text"></div>
            <div id="outro-canvas-container"></div>
        </section>
        
        <div class="nav-fixed"><div class="nav-link" onclick="location.reload()">RESTART</div></div>
        
        <div class="credits-fixed">WEBPAGE GENERATED BY GEMINI ¬∑ MUSIC BY SUNO</div>
    </div>

    <canvas id="process-canvas"></canvas>

    <script type="x-shader/x-vertex" id="vs-zen">
        uniform float time; attribute float size; varying float vOpacity;
        void main() { vec3 pos = position; pos.y -= time * 5.0; pos.x += sin(time * 0.5 + pos.z * 0.05) * 5.0; if (pos.y < -100.0) pos.y += 200.0; vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0); gl_PointSize = size * (300.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; vOpacity = smoothstep(150.0, 0.0, -mvPosition.z); }
    </script>
    <script type="x-shader/x-fragment" id="fs-zen">
        uniform vec3 color; varying float vOpacity; void main() { float d = distance(gl_PointCoord, vec2(0.5)); if(d > 0.5) discard; gl_FragColor = vec4(color, vOpacity * 0.5); }
    </script>
    <script type="x-shader/x-vertex" id="vs-hiphop">
        uniform float time; uniform float uEnergy; attribute vec3 offset; attribute vec3 colorAttr; varying vec3 vColor;
        void main() { vec3 pos = offset; pos += sin(pos * 10.0 + time * 20.0) * uEnergy * 5.0; float angle = time + length(pos.xy)*0.05; float c = cos(angle); float s = sin(angle); pos.xy = mat2(c, -s, s, c) * pos.xy; vColor = colorAttr; gl_Position = projectionMatrix * modelViewMatrix * vec4(position + pos, 1.0); }
    </script>
    <script type="x-shader/x-fragment" id="fs-hiphop">
        varying vec3 vColor; void main() { gl_FragColor = vec4(vColor, 0.8); }
    </script>
    <script type="x-shader/x-vertex" id="vs-triphop">
        uniform float time; uniform float uFlow; varying vec2 vUv; void main() { vUv = uv; vec3 pos = position; float wave = sin(uv.x * 10.0 + time) * cos(uv.y * 10.0 + time); pos.z += wave * (5.0 + uFlow * 20.0); gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0); }
    </script>
    <script type="x-shader/x-fragment" id="fs-triphop">
        uniform float time; varying vec2 vUv; void main() { vec3 c1 = vec3(0.2, 0.0, 0.4); vec3 c2 = vec3(0.0, 0.8, 0.8); float p = sin(vUv.x * 20.0 + time) * sin(vUv.y * 20.0 - time); gl_FragColor = vec4(mix(c1, c2, p * 0.5 + 0.5), 0.6); }
    </script>

    <script type="x-shader/x-vertex" id="vs-sky">
        varying vec3 vWorldPosition;
        void main() {
            vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
            vWorldPosition = worldPosition.xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>
    <script type="x-shader/x-fragment" id="fs-sky">
        uniform vec3 topColor; uniform vec3 bottomColor; uniform float offset; uniform float exponent; varying vec3 vWorldPosition;
        void main() {
            float h = normalize( vWorldPosition + offset ).y;
            gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
        }
    </script>

    <script>
        // --- 0. NEW: Audio Manager ---
        let bgmPlaying = false;
        function toggleAudio() {
            const bgm = document.getElementById('bgm');
            const btn = document.getElementById('audio-toggle');
            if(bgm.paused) {
                bgm.play().then(() => {
                    bgmPlaying = true;
                    btn.classList.remove('muted');
                }).catch(e => console.log("Audio waiting for user interaction"));
            } else {
                bgm.pause();
                bgmPlaying = false;
                btn.classList.add('muted');
            }
        }

        // --- 1. NEW: Digital Wisp (Mouse Follower) ---
        function initWisp() {
            const canvas = document.getElementById('wisp-canvas');
            const ctx = canvas.getContext('2d');
            let w, h;
            let mx = -100, my = -100; // Mouse coords
            let tx = -100, ty = -100; // Trail coords (lerped)
            const history = [];

            const resize = () => { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; };
            window.addEventListener('resize', resize);
            window.addEventListener('mousemove', e => { mx = e.clientX; my = e.clientY; });
            resize();

            // Set initial position
            mx = w/2; my = h/2; tx = mx; ty = my;

            function animateWisp() {
                ctx.clearRect(0, 0, w, h);
                
                // Lerp for smooth following
                tx += (mx - tx) * 0.08;
                ty += (my - ty) * 0.08;

                // Add slight sine wave hover if static
                const time = Date.now() * 0.002;
                const hoverY = Math.sin(time) * 5;

                // History trail
                history.push({x: tx, y: ty + hoverY});
                if(history.length > 20) history.shift();

                // Draw trail
                ctx.beginPath();
                for(let i=0; i<history.length; i++) {
                    const p = history[i];
                    if(i===0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
                ctx.strokeStyle = `rgba(255, 174, 0, 0.3)`;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Draw Core
                const grad = ctx.createRadialGradient(tx, ty + hoverY, 0, tx, ty + hoverY, 15);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.4, 'rgba(255, 174, 0, 0.8)');
                grad.addColorStop(1, 'rgba(255, 174, 0, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(tx, ty + hoverY, 15, 0, Math.PI*2);
                ctx.fill();

                requestAnimationFrame(animateWisp);
            }
            animateWisp();
        }

        // --- System Initialization ---
        function initializeSystem() {
            document.getElementById('start-screen').classList.add('hidden');
            document.body.classList.add('flashing');
            
            // Try to play BGM on start
            const bgm = document.getElementById('bgm');
            bgm.play().then(() => {
                bgmPlaying = true;
            }).catch(e => {
                console.log("Audio blocked, use toggle");
                document.getElementById('audio-toggle').classList.add('muted');
            });

            setTimeout(() => {
                document.body.classList.remove('flashing');
                document.body.classList.add('active');
                updateVine();
                initSlideshows(); 
                initWisp(); // Start the wisp
            }, 100);
        }

        // --- Slideshows ---
        function initSlideshows() {
            const screens = document.querySelectorAll('.cyber-screen');
            screens.forEach((screen, index) => {
                const slides = screen.querySelectorAll('.slide');
                let currentIdx = 0;
                const intervalTime = 3500 + Math.random() * 2000;
                setInterval(() => {
                    slides[currentIdx].classList.remove('active');
                    currentIdx = (currentIdx + 1) % slides.length;
                    slides[currentIdx].classList.add('active');
                }, intervalTime);
            });
        }

        // --- Background Soul Tree ---
        const canvas = document.getElementById('soul-tree-canvas'); const ctx = canvas.getContext('2d');
        let w, h; const tentacles = []; const numTentacles = 100; const spiritParticles = []; 
        function resize() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; initTentacles(); updateVine(); }
        window.addEventListener('resize', resize);
        class Tentacle { constructor() { this.reset(); } reset() { this.x = w / 2 + (Math.random() - 0.5) * w * 0.6; this.y = h + Math.random() * 100; this.segments = []; this.numSegments = 60; this.segHeight = (h + 250) / this.numSegments; this.angleOffset = Math.random() * Math.PI * 2; this.waveSpeed = Math.random() * 0.015 + 0.005; this.colorBase = Math.random() > 0.5 ? '255, 174, 0' : '255, 69, 0'; this.thickness = Math.random() * 1.8 + 0.3; for(let i=0; i<this.numSegments; i++) { this.segments.push({ x: this.x, y: this.y - i * this.segHeight }); } } update(time) { for(let i=0; i<this.numSegments; i++) { const sway = Math.sin(time * this.waveSpeed + i * 0.08 + this.angleOffset) * (i * 0.6); this.segments[i].x = this.x + sway + (this.x - w/2) * (i/this.numSegments) * 0.8; } } draw() { ctx.beginPath(); ctx.moveTo(this.segments[0].x, this.segments[0].y); for(let i=1; i<this.numSegments - 1; i++) { const xc = (this.segments[i].x + this.segments[i+1].x) / 2; const yc = (this.segments[i].y + this.segments[i+1].y) / 2; ctx.quadraticCurveTo(this.segments[i].x, this.segments[i].y, xc, yc); } const gradient = ctx.createLinearGradient(this.x, h, this.x, 0); gradient.addColorStop(0, `rgba(${this.colorBase}, 0)`); gradient.addColorStop(0.3, `rgba(${this.colorBase}, 0.5)`); gradient.addColorStop(1, `rgba(${this.colorBase}, 0)`); ctx.strokeStyle = gradient; ctx.lineWidth = this.thickness; ctx.stroke(); } }
        class Spirit { constructor() { this.reset(); } reset() { this.x = Math.random() * w; this.y = h + Math.random() * 100; this.vy = Math.random() * 0.8 + 0.2; this.size = Math.random() * 1.5; this.alpha = Math.random(); } update() { this.y -= this.vy; if(this.y < 0) this.reset(); } draw() { ctx.fillStyle = `rgba(255, 200, 100, ${this.alpha * 0.4})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); } }
        function initTentacles() { tentacles.length = 0; spiritParticles.length = 0; for(let i=0; i<numTentacles; i++) tentacles.push(new Tentacle()); for(let i=0; i<60; i++) spiritParticles.push(new Spirit()); }
        let globalTime = 0; function animateTree() { ctx.fillStyle = 'rgba(10, 5, 0, 0.1)'; ctx.fillRect(0, 0, w, h); ctx.globalCompositeOperation = 'lighter'; globalTime += 1; tentacles.forEach(t => { t.update(globalTime); t.draw(); }); spiritParticles.forEach(s => { s.update(); s.draw(); }); ctx.globalCompositeOperation = 'source-over'; requestAnimationFrame(animateTree); }
        resize(); animateTree();

        // --- 2. Vine Navigation ---
        function updateVine() {
            const container = document.querySelector('.vine-section'); const intro = document.getElementById('intro-anchor');
            const n1 = document.getElementById('node-1'); const n2 = document.getElementById('node-2'); const n3 = document.getElementById('node-3');
            if(!intro || !n1 || !n2 || !n3) return;
            const getCenter = (el) => { const r = el.getBoundingClientRect(); const c = container.getBoundingClientRect(); return { x: r.left + r.width/2 - c.left, y: r.top + r.height/2 - c.top }; };
            const p0 = { x: container.offsetWidth/2, y: intro.offsetTop + intro.offsetHeight }; const p1 = getCenter(n1); const p2 = getCenter(n2); const p3 = getCenter(n3);
            const pathData = `M ${p0.x} ${p0.y} C ${p0.x} ${p0.y+150}, ${p1.x} ${p1.y-150}, ${p1.x} ${p1.y} S ${p2.x} ${p2.y-150}, ${p2.x} ${p2.y} S ${p3.x} ${p3.y-150}, ${p3.x} ${p3.y} L ${container.offsetWidth/2} ${container.offsetHeight}`;
            document.getElementById('vine-bg').setAttribute('d', pathData); const vm = document.getElementById('vine-main'); vm.setAttribute('d', pathData);
            const len = vm.getTotalLength(); vm.style.strokeDasharray = len;
            document.getElementById('main-interface').addEventListener('scroll', (e) => {
                const pct = e.target.scrollTop / (e.target.scrollHeight - window.innerHeight);
                vm.style.strokeDashoffset = len - len * Math.min(pct * 2, 1);
            });
        }
        const observer = new IntersectionObserver((e)=>{e.forEach(i=>{if(i.isIntersecting)i.target.classList.add('is-visible')})}, {threshold:0.3});
        document.querySelectorAll('.node-block, .transition-title-block').forEach(b=>observer.observe(b));

        // --- 3. Hologram Stage ---
        (function() {
            const container = document.getElementById('three-container'); const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight * 0.9), 0.1, 1000); camera.position.z = 120; camera.position.y = 10;
            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight * 0.9); container.appendChild(renderer.domElement);
            const video = document.createElement('video'); video.src = 'images/wingchun.mp4'; video.loop = true; video.muted = true; video.play().catch(e=>console.log("Video not found, using noise fallback")); video.setAttribute('playsinline', '');
            const texture = new THREE.VideoTexture(video); texture.minFilter = THREE.LinearFilter;
            const densityX = 400; const densityY = 200; const particleCount = densityX * densityY;
            const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(particleCount * 3); const uvs = new Float32Array(particleCount * 2);
            let index = 0; const width = 180; const height = 100;
            for (let y = 0; y < densityY; y++) { for (let x = 0; x < densityX; x++) { uvs[index * 2] = x / (densityX - 1); uvs[index * 2 + 1] = y / (densityY - 1); const xPos = (x / (densityX - 1) - 0.5) * width; const yPos = (y / (densityY - 1) - 0.5) * height; positions[index * 3] = xPos; positions[index * 3 + 1] = yPos; positions[index * 3 + 2] = 0; index++; } }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            const mat = new THREE.ShaderMaterial({
                uniforms: { t: { value: texture }, time: { value: 0 }, colHigh: { value: new THREE.Color(0xffffff) }, colLow: { value: new THREE.Color(0xff4500) } },
                vertexShader: `uniform sampler2D t; varying vec2 vUv; varying float vVis; void main() { vUv = uv; vec4 c = texture2D(t, uv); float b = (c.r + c.g + c.b) / 3.0; if(b < 0.1) b = sin(uv.x*10.0+uv.y*10.0)*0.1; vVis = smoothstep(0.05, 0.4, b); vec3 p = position; p.z += b * 40.0 * vVis; gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0); gl_PointSize = (2.0 * vVis + 0.1); }`,
                fragmentShader: `uniform vec3 colHigh; uniform vec3 colLow; uniform float time; varying float vVis; varying vec2 vUv; void main() { if (vVis < 0.1) discard; vec3 finalCol = mix(colLow, colHigh, smoothstep(0.4, 0.7, vVis)); float scan = sin(vUv.y * 5.0 - time * 3.0); if(scan > 0.95) finalCol = vec3(1.0); gl_FragColor = vec4(finalCol, vVis * 0.9); }`,
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            const particles = new THREE.Points(geometry, mat); scene.add(particles);
            function animate() { requestAnimationFrame(animate); mat.uniforms.time.value += 0.02; renderer.render(scene, camera); }
            animate();
        })();

        // --- LAB 1: AUDIO VIZ ---
        let labCtx, analyser, labOsc, labLoop, currentAudioMode='zen';
        function setAudioMode(mode) { currentAudioMode = mode; }
        function startAudioPreview() {
            if(!labCtx) { labCtx = new (window.AudioContext || window.webkitAudioContext)(); analyser = labCtx.createAnalyser(); analyser.fftSize = 64; analyser.connect(labCtx.destination); }
            if(labCtx.state === 'suspended') labCtx.resume();
            let beat = 0;
            labLoop = setInterval(() => {
                const t = labCtx.currentTime;
                if(currentAudioMode === 'zen') {
                   if(beat%8===0) { const o=labCtx.createOscillator(); o.frequency.value=220; const g=labCtx.createGain(); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.2,t+0.1); g.gain.exponentialRampToValueAtTime(0.01,t+2); o.connect(g); g.connect(analyser); o.start(); o.stop(t+2); }
                } else if(currentAudioMode === 'hiphop') {
                   if(beat%4===0) { const o=labCtx.createOscillator(); o.frequency.setValueAtTime(150,t); o.frequency.exponentialRampToValueAtTime(0.01,t+0.3); const g=labCtx.createGain(); g.gain.setValueAtTime(1,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.3); o.connect(g); g.connect(analyser); o.start(); o.stop(t+0.3); }
                   if(beat%2===1) { const o=labCtx.createOscillator(); o.type='square'; o.frequency.value=800; const g=labCtx.createGain(); g.gain.setValueAtTime(0.1,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.05); o.connect(g); g.connect(analyser); o.start(); o.stop(t+0.05); }
                } else {
                   const o=labCtx.createOscillator(); o.type='sawtooth'; o.frequency.value=174+Math.random()*2; const f=labCtx.createBiquadFilter(); f.frequency.value=300; const g=labCtx.createGain(); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.1,t+0.5); g.gain.linearRampToValueAtTime(0,t+1); o.connect(f); f.connect(g); g.connect(analyser); o.start(); o.stop(t+1);
                }
                beat++;
            }, 250);
            renderAudioViz();
        }
        function stopAudioPreview() { if(labLoop) clearInterval(labLoop); }
        function renderAudioViz() {
            const cvs = document.getElementById('viz-audio');
            if(!cvs || !analyser) return;
            const c = cvs.getContext('2d'); cvs.width=cvs.offsetWidth; cvs.height=cvs.offsetHeight;
            const data = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(data);
            c.clearRect(0,0,cvs.width,cvs.height); c.fillStyle = '#ffae00';
            const bw = cvs.width/data.length;
            for(let i=0; i<data.length; i++) {
                const h = (data[i]/255)*cvs.height;
                if(currentAudioMode==='zen') { c.beginPath(); c.arc(cvs.width/2, cvs.height/2, h/2, 0, Math.PI*2); c.strokeStyle='#ffae00'; c.stroke(); }
                else if(currentAudioMode==='hiphop') c.fillRect(i*bw, cvs.height-h, bw-2, h);
                else { c.beginPath(); c.arc(i*bw, cvs.height/2 + (Math.random()-0.5)*h, 2, 0, Math.PI*2); c.fill(); }
            }
            if(labLoop) requestAnimationFrame(renderAudioViz);
        }

        // --- LAB 2: SCENE VIZ ---
        let sceneAnim, currentSceneMode='void';
        function setSceneMode(mode) { currentSceneMode=mode; }
        function startSceneViz() { renderSceneViz(); }
        function stopSceneViz() { cancelAnimationFrame(sceneAnim); }
        function renderSceneViz() {
            const cvs = document.getElementById('viz-scene'); const c = cvs.getContext('2d');
            cvs.width=cvs.offsetWidth; cvs.height=cvs.offsetHeight;
            c.clearRect(0,0,cvs.width,cvs.height);
            const t = Date.now()*0.001;
            c.fillStyle='#fff'; c.strokeStyle='#ffae00';
            if(currentSceneMode==='void') { c.beginPath(); c.arc(cvs.width/2, cvs.height/2, 50+Math.sin(t)*10, 0, Math.PI*2); c.stroke(); }
            else if(currentSceneMode==='concrete') { for(let i=0;i<10;i++) c.strokeRect(cvs.width/2-50+Math.sin(t+i)*20, cvs.height/2-50+Math.cos(t+i)*20, 100, 100); }
            else { c.beginPath(); for(let x=0; x<cvs.width; x+=10) c.lineTo(x, cvs.height/2 + Math.sin(t*2 + x*0.05)*30); c.stroke(); }
            sceneAnim = requestAnimationFrame(renderSceneViz);
        }

        // --- LAB 3: 3D AVATAR ---
        let avScene, avCam, avRen, avRobot, avAnimId, currentAvatarMode='wingchun';
        function initLab3D() {
            const cont = document.getElementById('avatar-3d-container');
            avScene = new THREE.Scene();
            avCam = new THREE.PerspectiveCamera(50, cont.offsetWidth/cont.offsetHeight, 0.1, 100); avCam.position.set(0, 10, 40);
            avRen = new THREE.WebGLRenderer({alpha:true, antialias:true}); avRen.setSize(cont.offsetWidth, cont.offsetHeight);
            cont.appendChild(avRen.domElement);
            avRobot = new THREE.Group();
            const mat = new THREE.MeshBasicMaterial({color:0xffae00, wireframe:true});
            const createLimb = (w,h,d,y) => { const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat); m.position.y=y; return m; }
            const torso = createLimb(6,10,4, 5); avRobot.add(torso);
            const head = createLimb(4,5,4, 14); avRobot.add(head);
            const lArm = new THREE.Group(); lArm.position.set(-4,9,0); const lArmMesh = createLimb(2,8,2, -4); lArm.add(lArmMesh); avRobot.add(lArm);
            const rArm = new THREE.Group(); rArm.position.set(4,9,0); const rArmMesh = createLimb(2,8,2, -4); rArm.add(rArmMesh); avRobot.add(rArm);
            const lLeg = new THREE.Group(); lLeg.position.set(-2,0,0); const lLegMesh = createLimb(2.5,10,2.5, -5); lLeg.add(lLegMesh); avRobot.add(lLeg);
            const rLeg = new THREE.Group(); rLeg.position.set(2,0,0); const rLegMesh = createLimb(2.5,10,2.5, -5); rLeg.add(rLegMesh); avRobot.add(rLeg);
            avRobot.parts = {head, lArm, rArm, lLeg, rLeg}; avScene.add(avRobot);
        }
        function setAvatarMode(mode) { currentAvatarMode = mode; }
        function startAvatar() { if(!avScene) initLab3D(); animateAvatar(); }
        function stopAvatar() { cancelAnimationFrame(avAnimId); }
        function animateAvatar() {
            avAnimId = requestAnimationFrame(animateAvatar);
            const t = Date.now() * 0.005; const p = avRobot.parts;
            if(currentAvatarMode === 'wingchun') { p.lArm.rotation.z = -0.5; p.lArm.rotation.x = Math.sin(t)*0.2 - 0.5; p.rArm.rotation.z = 0.5; p.rArm.rotation.x = Math.cos(t)*0.2 - 0.5; p.lLeg.rotation.x = 0; p.rLeg.rotation.x = 0; avRobot.position.y = 0; }
            else if(currentAvatarMode === 'hiphop') { const bounce = Math.abs(Math.sin(t*2)); avRobot.position.y = bounce * 2; p.lArm.rotation.z = Math.sin(t)*0.5 - 1; p.lArm.rotation.x = 0; p.rArm.rotation.z = -Math.sin(t)*0.5 + 1; p.rArm.rotation.x = 0; p.lLeg.rotation.x = -bounce*0.5; p.rLeg.rotation.x = -bounce*0.5; }
            else { avRobot.position.y = Math.sin(t)*2 + 2; avRobot.rotation.z = Math.sin(t*0.5)*0.2; p.lArm.rotation.z = -2 + Math.sin(t)*0.5; p.rArm.rotation.z = 2 + Math.cos(t)*0.5; p.lLeg.rotation.x = Math.sin(t)*0.2; p.rLeg.rotation.x = Math.cos(t)*0.2; }
            avRen.render(avScene, avCam);
        }

        // --- 4. Chronos Gate ---
        let chronosRunning = false;
        let cScene, cCam, cRenderer, cClock;
        let cGroups = [], hiphopU, triphopU;
        let audioCtx, zenNodes=[], triphopNodes=[], hiphopTimer=null;
        const WORLDS = { ZEN: 0, HIPHOP: 1, TRIPHOP: 2 };
        let curWorld = WORLDS.ZEN;
        const videoEl = document.getElementById('webcam-preview');
        const mCanvas = document.getElementById('process-canvas'); const mCtx = mCanvas.getContext('2d', {willReadFrequently:true});
        const dCanvas = document.getElementById('motion-debug'); const dCtx = dCanvas.getContext('2d');
        let lastFrame = null; let eCenter=0, eEdge=0, sTimer=0;
        let isChronosVisible = false;
        
        async function initChronosGate() {
            document.querySelector('.gate-start-layer').classList.add('hidden');
            document.querySelector('.gate-hud').classList.add('active');
            document.querySelector('.gate-controls').classList.add('visible');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 160, height: 120 }, audio: false });
                videoEl.srcObject = stream;
                mCanvas.width = 32; mCanvas.height = 24; dCanvas.width = 32; dCanvas.height = 24;
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                const container = document.getElementById('chronos-container');
                cClock = new THREE.Clock(); cScene = new THREE.Scene();
                cCam = new THREE.PerspectiveCamera(65, container.offsetWidth/container.offsetHeight, 0.1, 2000); cCam.position.z = 100;
                cRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); cRenderer.setSize(container.offsetWidth, container.offsetHeight);
                container.appendChild(cRenderer.domElement);

                createZenWorld(); createHipHopWorld(); createTripHopWorld();
                
                chronosRunning = true; 
                cAnimate(); cMotionLoop(); 

                const gateSection = document.querySelector('.chronos-section');
                const audioObserver = new IntersectionObserver((entries) => {
                    entries.forEach(e => {
                        if(!chronosRunning) return;
                        isChronosVisible = e.isIntersecting;

                        if(e.isIntersecting) { 
                            if(audioCtx.state === 'suspended') audioCtx.resume(); 
                            startWorldAudio(curWorld); 
                        } else { 
                            stopZenAudio(); stopHipHopAudio(); stopTripHopAudio(); 
                        }
                    });
                }, { threshold: 0.1 });
                audioObserver.observe(gateSection);
            } catch (e) { console.error(e); alert("Please enable camera access."); }
        }

        // --- AUDIO ENGINES ---
        function startZenAudio() {
            const createDrone = (freq) => { const osc = audioCtx.createOscillator(); osc.frequency.value = freq; const gain = audioCtx.createGain(); gain.gain.value = 0.05; osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); return {o:osc, g:gain}; };
            zenNodes.push(createDrone(110)); zenNodes.push(createDrone(112));
            const bowlLoop = setInterval(() => { const t = audioCtx.currentTime; [220, 540, 800].forEach(f => { const o = audioCtx.createOscillator(); o.frequency.value = f; const g = audioCtx.createGain(); g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.1, t + 0.1); g.gain.exponentialRampToValueAtTime(0.001, t + 6); o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(t + 6); }); }, 8000);
            zenNodes.push({interval: bowlLoop});
        }
        function stopZenAudio() { zenNodes.forEach(n => { if(n.o) { n.g.gain.setTargetAtTime(0, audioCtx.currentTime, 0.5); setTimeout(()=>n.o.stop(), 500); } if(n.interval) clearInterval(n.interval); }); zenNodes = []; }
        function playKick(t) { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5); gain.gain.setValueAtTime(1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(t); osc.stop(t + 0.5); }
        function playSnare(t) { const bufferSize = audioCtx.sampleRate * 0.2; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); const data = buffer.getChannelData(0); for (let i=0; i<bufferSize; i++) data[i]=(Math.random()*2-1); const noise = audioCtx.createBufferSource(); noise.buffer = buffer; const filter = audioCtx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.value = 1000; const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.8, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2); noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); noise.start(t); }
        function playHat(t) { const bufferSize = audioCtx.sampleRate * 0.05; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); const data = buffer.getChannelData(0); for (let i=0; i<bufferSize; i++) data[i]=(Math.random()*2-1); const noise = audioCtx.createBufferSource(); noise.buffer = buffer; const filter = audioCtx.createBiquadFilter(); filter.type = 'highpass'; filter.frequency.value = 5000; const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05); noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); noise.start(t); }
        function startHipHopAudio() { let beat = 0; const stepTime = 60/90/2; hiphopTimer = setInterval(() => { const t = audioCtx.currentTime; if(beat%8 === 0) playKick(t); if(beat%8 === 2) playHat(t); if(beat%8 === 4) { playSnare(t); playKick(t+0.1); } if(beat%8 === 6) playHat(t); beat++; }, stepTime * 1000); }
        function stopHipHopAudio() { clearInterval(hiphopTimer); }
        function startTripHopAudio() { const freqs = [174.61, 207.65, 261.63, 311.13]; const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 400; const lfo = audioCtx.createOscillator(); lfo.frequency.value = 0.2; const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 200; lfo.connect(lfoGain); lfoGain.connect(filter.frequency); const masterG = audioCtx.createGain(); masterG.gain.value = 0; filter.connect(masterG); masterG.connect(audioCtx.destination); freqs.forEach(f => { const osc = audioCtx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = f + (Math.random()-0.5)*2; osc.connect(filter); osc.start(); triphopNodes.push(osc); }); lfo.start(); triphopNodes.push(lfo); triphopNodes.push(masterG); masterG.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 2); }
        function stopTripHopAudio() { if(triphopNodes.length>0) { const g = triphopNodes[triphopNodes.length-1]; if(g && g.gain) g.gain.setTargetAtTime(0, audioCtx.currentTime, 0.5); setTimeout(() => { triphopNodes.forEach(n => { try{n.stop()}catch(e){} }); triphopNodes=[]; }, 1000); } }
        function startWorldAudio(idx) { stopZenAudio(); stopHipHopAudio(); stopTripHopAudio(); if(idx === 0) startZenAudio(); if(idx === 1) startHipHopAudio(); if(idx === 2) startTripHopAudio(); }

        // --- WORLD LOGIC ---
        function createZenWorld() {
            const g = new THREE.Group(); cGroups.push(g);
            const geo = new THREE.BufferGeometry(); const pos=[], size=[];
            for(let i=0;i<1000;i++){ pos.push((Math.random()-0.5)*300,(Math.random()-0.5)*300,(Math.random()-0.5)*200); size.push(Math.random()*4+2); }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3)); geo.setAttribute('size', new THREE.Float32BufferAttribute(size,1));
            g.add(new THREE.Points(geo, new THREE.ShaderMaterial({ uniforms:{time:{value:0}, color:{value:new THREE.Color(0xffccaa)}}, vertexShader:document.getElementById('vs-zen').textContent, fragmentShader:document.getElementById('fs-zen').textContent, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false })));
            cScene.add(g);
        }
        function createHipHopWorld() {
            const g = new THREE.Group(); cGroups.push(g);
            const base = new THREE.TetrahedronGeometry(4); const geo = new THREE.InstancedBufferGeometry();
            geo.index = base.index; geo.attributes.position = base.attributes.position;
            const off=[], col=[]; for(let i=0;i<500;i++){ off.push((Math.random()-0.5)*200,(Math.random()-0.5)*200,(Math.random()-0.5)*200); col.push(Math.random()>0.5?1:0, 0, Math.random()>0.5?0:1); }
            geo.setAttribute('offset', new THREE.InstancedBufferAttribute(new Float32Array(off),3)); geo.setAttribute('colorAttr', new THREE.InstancedBufferAttribute(new Float32Array(col),3));
            hiphopU = {time:{value:0}, uEnergy:{value:0}};
            g.add(new THREE.Mesh(geo, new THREE.ShaderMaterial({uniforms:hiphopU, vertexShader:document.getElementById('vs-hiphop').textContent, fragmentShader:document.getElementById('fs-hiphop').textContent, transparent:true, blending:THREE.AdditiveBlending})));
            cScene.add(g); g.visible=false;
        }
        function createTripHopWorld() {
            const g = new THREE.Group(); cGroups.push(g);
            const geo = new THREE.PlaneGeometry(400,400,60,60); triphopU = {time:{value:0}, uFlow:{value:0}};
            const m = new THREE.Mesh(geo, new THREE.ShaderMaterial({uniforms:triphopU, vertexShader:document.getElementById('vs-triphop').textContent, fragmentShader:document.getElementById('fs-triphop').textContent, transparent:true, opacity:0.6, wireframe:true}));
            m.rotation.x=-Math.PI/2; m.position.y=-50; g.add(m); cScene.add(g); g.visible=false;
        }
        function switchWorld(idx) {
            if(curWorld===idx) return;
            curWorld = idx;
            const ui = [ 
                {t:"ZEN REALM", s:"ZEN MEDITATION ¬∑ BOWL", c:"#000", i:"‚õ©Ô∏è"}, 
                {t:"THE BRONX", s:"STREET RHYTHM ¬∑ FLOW", c:"#100", i:"üî•"}, 
                {t:"VOID CLUB", s:"PSYCHEDELIC ¬∑ TRANCE", c:"#001", i:"üåå"} 
            ][idx];
            document.getElementById('gate-ui-title').innerText = ui.t; document.getElementById('gate-ui-sub').innerText = ui.s;
            document.getElementById('gate-ui-icon').innerText = ui.i; document.querySelector('.chronos-section').style.backgroundColor = ui.c;
            cGroups.forEach((g,i)=>g.visible=(i===idx));
            
            if(isChronosVisible) {
                startWorldAudio(idx);
            }
            eCenter=0; eEdge=0; sTimer=0;
        }
        function cAnimate() { if(!chronosRunning) return; requestAnimationFrame(cAnimate); const t = cClock.getElapsedTime(); if(curWorld===0) cGroups[0].children[0].material.uniforms.time.value = t; if(curWorld===1) hiphopU.time.value = t; if(curWorld===2) triphopU.time.value = t; cRenderer.render(cScene, cCam); }
        function cMotionLoop() {
            if(!chronosRunning) { requestAnimationFrame(cMotionLoop); return; }
            const w=32, h=24; mCtx.drawImage(videoEl, 0, 0, w, h); const frame = mCtx.getImageData(0,0,w,h); dCtx.fillStyle='#000'; dCtx.fillRect(0,0,w,h);
            if(lastFrame) {
                let center=0, edge=0, total=0;
                for(let i=0; i<frame.data.length; i+=4) {
                    if(Math.abs(frame.data[i]-lastFrame.data[i]) > 20) { total++; const p=i/4; const x=p%w; const y=Math.floor(p/w); dCtx.fillStyle='#0f0'; dCtx.fillRect(x,y,1,1); if(x>w*0.35 && x<w*0.65 && y>h*0.35 && y<h*0.65) center++; else if(x<w*0.2 || x>w*0.8) edge++; }
                }
                if(total<5) { sTimer++; if(sTimer>60 && curWorld!==0) switchWorld(0); } 
                else { sTimer=0; if(center>10 && curWorld!==1) { eCenter++; if(eCenter>5) switchWorld(1); } else eCenter=0; if(edge>10 && curWorld!==2) { eEdge++; if(eEdge>8) switchWorld(2); } else eEdge=0; }
                if(curWorld===1 && center>5) hiphopU.uEnergy.value=1; else if(curWorld===1) hiphopU.uEnergy.value*=0.9;
                if(curWorld===2 && edge>5) triphopU.uFlow.value=1; else if(curWorld===2) triphopU.uFlow.value*=0.95;
            }
            lastFrame = frame; requestAnimationFrame(cMotionLoop);
        }

        // --- 5. Outro: The Infinite Black & White World (Fixed) ---
        (function() {
            const container = document.getElementById('outro-canvas-container');
            if(!container) return;

            // --- Scene Setup ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Black Void
            scene.fog = new THREE.FogExp2(0x000000, 0.02); // Dark fog to blend ground

            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 45); // Adjust camera back a bit

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = 1.2; 
            container.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; 
            controls.minDistance = 10;
            controls.maxDistance = 100;
            controls.enableZoom = false; 
            controls.enablePan = false;

            // --- 2. Ground: Soft Powder Snow (White) ---
            function createNoiseTexture() {
                const size = 512; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, size, size);
                for (let i = 0; i < 20000; i++) { const x = Math.random() * size; const y = Math.random() * size; const val = Math.random() * 20 + 235; ctx.fillStyle = `rgb(${val},${val},${val})`; ctx.fillRect(x, y, 2, 2); }
                const texture = new THREE.CanvasTexture(canvas); texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(20, 20); return texture;
            }
            const iceTexture = createNoiseTexture();
            const planeGeo = new THREE.PlaneGeometry(1000, 1000, 256, 256); 
            const posAttribute = planeGeo.attributes.position;
            for (let i = 0; i < posAttribute.count; i++) {
                const x = posAttribute.getX(i); const y = posAttribute.getY(i);
                // Slight bumps
                const z = Math.sin(x * 0.02) * Math.cos(y * 0.02) * 1.5 + Math.random() * 0.1;
                posAttribute.setZ(i, z);
            }
            planeGeo.computeVertexNormals();

            const planeMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                map: iceTexture, 
                roughness: 0.9, 
                metalness: 0.1, 
                bumpMap: iceTexture, 
                bumpScale: 0.05 
            });
            const ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // --- 3. Rising Lines (Particles) ---
            const lineGeo = new THREE.BufferGeometry();
            const lineCount = 400; // Number of lines
            const linePos = [];
            for(let i=0; i<lineCount; i++) {
                // Random spread
                const x = (Math.random() - 0.5) * 150;
                const z = (Math.random() - 0.5) * 150;
                const y = Math.random() * 100;
                // Create a vertical segment: bottom and top vertex
                linePos.push(x, y, z);
                linePos.push(x, y + 5 + Math.random() * 5, z); // Length 5-10
            }
            lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
            const lineMat = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });
            const risingLines = new THREE.LineSegments(lineGeo, lineMat);
            scene.add(risingLines);

            // --- 4. The Door (Small, Centered, Glowing) ---
            const doorGroup = new THREE.Group();
            
            // Texture for glow
            function getLightTexture() {
                const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 128; const ctx = canvas.getContext('2d');
                const grd = ctx.createRadialGradient(32, 64, 5, 32, 64, 60);
                grd.addColorStop(0, "rgba(255, 220, 180, 1)"); 
                grd.addColorStop(0.4, "rgba(255, 140, 0, 0.8)"); 
                grd.addColorStop(1, "rgba(255, 100, 0, 0)"); 
                ctx.fillStyle = grd; ctx.fillRect(0, 0, 64, 128);
                return new THREE.CanvasTexture(canvas);
            }

            // Light Sheet (Scaled Down)
            const sheetGeo = new THREE.PlaneGeometry(4, 8); // Smaller size
            const sheetMat = new THREE.MeshBasicMaterial({ 
                map: getLightTexture(),
                color: 0xffaa00, side: THREE.DoubleSide, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false 
            });
            const sheet = new THREE.Mesh(sheetGeo, sheetMat);
            sheet.position.y = 4; // Center on y-axis (half height)

            // Border
            const borderGeo = new THREE.BoxGeometry(4.2, 8.2, 0.1); 
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.05, blending: THREE.AdditiveBlending });
            const border = new THREE.Mesh(borderGeo, borderMat); border.position.y = 4;

            // Rim Lines
            const edges = new THREE.EdgesGeometry(borderGeo);
            const rimMat = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
            const rims = new THREE.LineSegments(edges, rimMat); rims.position.y = 4;

            doorGroup.add(sheet); doorGroup.add(border); doorGroup.add(rims);
            scene.add(doorGroup);

            // --- 5. Lighting ---
            const ambient = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
            scene.add(ambient);
            
            // Spotlight on the door area to light up the snow beneath
            const spotLight = new THREE.SpotLight(0xffaa00, 10, 60, 0.5, 0.5, 1);
            spotLight.position.set(0, 20, 10);
            spotLight.target = doorGroup;
            spotLight.castShadow = true;
            scene.add(spotLight);

            // Orange Point light for local reflection
            const pLight = new THREE.PointLight(0xffaa00, 3, 20);
            pLight.position.set(0, 4, 2);
            scene.add(pLight);

            // --- 6. Typewriter Effect (Trigger) ---
            const textContent = "Beyond this door, there is nothing. No correct answers, no defined self, no singular path‚Äîonly freedom.\n\nAs Song Dynasty Zen Master Wumen Huikai wrote:\n'The Great Way has no gate, yet there are a thousand paths.'\n\nThe true way has no fixed form. Though its formlessness may be bewildering, your own unique path is always there.";
            const textEl = document.getElementById('outro-text');
            let hasTyped = false;

            const outroObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if(entry.isIntersecting && !hasTyped) {
                        hasTyped = true;
                        textEl.classList.add('visible');
                        let i = 0;
                        function type() {
                            if (i < textContent.length) {
                                textEl.innerText += textContent.charAt(i);
                                i++;
                                setTimeout(type, 30); 
                            }
                        }
                        type();
                    }
                });
            }, { threshold: 0.1 });
            outroObserver.observe(container);

            // --- 7. Animation Loop ---
            function animateScene() {
                requestAnimationFrame(animateScene);
                controls.update();
                const t = Date.now() * 0.002;
                
                // Pulse door
                sheet.material.opacity = 0.8 + Math.sin(t * 3) * 0.1;
                pLight.intensity = 3 + Math.sin(t * 5) * 1.0;

                // Animate rising lines (looping vertically)
                const pos = risingLines.geometry.attributes.position.array;
                for(let i=1; i<pos.length; i+=3) {
                    pos[i] += 0.15; // Speed up
                    if(pos[i] > 100) pos[i] = 0; // Reset to ground
                }
                risingLines.geometry.attributes.position.needsUpdate = true;

                renderer.render(scene, camera);
            }
            animateScene();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        })();
    </script>
</body>
</html>
